//====
Из основ:

Рекомендация повторить 
https://learn.javascript.ru/types-conversion
Это даст несколько лучшее понимание типов и преобразований типов в любом языке программирования. Хотя по сути нами всё это было пройдено. Там всё же есть пара новых и хитрых примеров, которые мы раньше явно не обговаривали. 

Внешние\глобальные переменные ( объявленные на уровне всего скрипта)
Рекомендация - использовать переменные на как можно более ограниченной области видимости (как и в джаве, инкапсуляция)

возможность неявного объявления переменных 
присвоением значения. Лучше забыть о такой. 
Но можно встретить в плохих примерах.
use strict.

//====Функции
Уточнил, что при передач простого параметра происходит таки копия. Как и в джаве с примитивными типами.

Любую функцию можно вызвать с любым количеством параметров, несмотря на её объявление. 
Следствие1 - при объявлении функции необязательные параметры стоит располагать в конце.
Следствие2 - перегрузка невозможна

Пример интересный, странный, но работает:
function showMessage(from, text) {
  text = text || 'текст не передан'; //
  alert(text);
}

специальный объект arguments: (рекомендуется никогда не изменять arguments)
интересная особенность реализации - arguments – это не массив Array. В действительности, это обычный объект, просто ключи числовые и есть length. 
function sayHi() {
  for (var i = 0; i < arguments.length; i++) {
    alert( "Привет, " + arguments[i] ); 
  }
}

Любая функция что-то возращает. Но если return отстутсвует, то возвращается undefined:

function doNothing() { /* пусто */ }
alert( doNothing() ); // undefined, без ошибки, просто значение такое

Function Declaration  vs Function Expression vs Анонимные. 
Главное отличие - декларированные доступны везде в области видимости (). Выражения - только ниже по коду, как переменные.

Function Declaration при use strict видны только внутри блока, в котором объявлены. Стоит только так и делать.

Прикольный и местами очень полезный способ создания функции на лету из строки (джавистам такая радость и не снилась):
new Function('a,b', ' return a+b; ');

Контекст выполнения и стэк контексто - очень важные понятия в любом языке программирования.

//Объекты:

первые примерs: 
"Привет, мир!".length  //тип String
"Привет, мир!".toUpperCase() vs "Привет, мир!".toUpperCase() //и прочие типичные для стринга методы 
[1, 2].forEach(alert) //и прочие типичные для списка\очереди\стэка методы. Например pop push shift unshift sort...
alert( 12.355.toFixed(1) ); // 12.0 тип Number
alert( 12..toFixed(1) ); // 12.0

Свои объекты:
каждый объект по сути своей есть ассоциативный массив, и не более того. Наследования нет. Но есть функционал расширения из образца.
Два способа создания:
1. SimpleObject = new Object();
2. o = {}; // пустые фигурные скобки

o.newValue = "new String in O". 
o.newValue2 = "new String2 in O". 
delete o.newValue
if ("something" in o) {...}
alert( o.noSuchProperty ); // undefined, но без ошибки
alert( o.noSuchProperty === undefined )

Различие между in и undefined. Подумать. Оно всего одно. Интересно додуматься.

Альтернативный способ работы со свойствами.
o.newValue vs o[newValue] по сути одно и то же, но применять стоит разному. Второй вариант гибче, первый строже и надежнее.

Под капотом браузер иногда создает метаобъеты, 
аналоги классов, если однотипных объектов 
становится много. Но это совсем под 
капотом, джаваскриптеру-практику про 
это можно даже не знать.

Итого, самое лучшее определение объекта в
джаваскрипте: "объекты – это ассоциативные массивы".
Но лучше всё же использовать объектную терминологию, 
как свойства и методы.

//======
Чуть больше про массивы

Определения массива в джаваскрипте - 
Массив – это объект, где в качестве ключей выбраны 
цифры. 
Хотя под капотом оно все же не так, было бы очень неоптимально. Ну с функционально-синтаксической точки зрения оно так.
И создать свой объект через {}, который при использовании будет неотличим от массива, созданного через [] можно легко.

Не используйте for..in для массивов. Во много-много раз медленнее будет. Да и свойства нецифровые может добавить.

Длина length – не количество элементов массива, а последний индекс + 1. 
var arr = [];
arr[1000] = true;
alert(arr.length); // 1001

массив длинной 100, но с элементами типа "налл" есть по сути такой объект:
{length: 2}.


//========
Доп синтаксис с объектами:
for (key in obj) { //key будет имя свойство, а не значение
  /* ... делать что-то с obj[key] ... */
}

но лучше 
for (var key in obj) { //key будет имя свойство, а не значение
  /* ... делать что-то с obj[key] ... */
}

а еще лучше
for (let key in obj) { //key будет имя свойство, а не значение
  /* ... делать что-то с obj[key] ... */
}

Порядок не гарантирован. 

//Ссылки vs значения
Как в джаве. Все объекты присваиваются и передаются как аргументы по ссылке. 
А примитивы - копируются как есть, включая строки.

//=======
Практическое задание. Закончить код:
"use strict";

var salaries = {
  "Вася": 100,
  "Петя": 300,
  "Даша": 250,
  new Document(): 12,
  topmanager: 1M
};

// вывести имя и зарплату самого нищего отрудника.


//=======
Практическая задача, наверное на дом:
LinkedList на джаваскрипте. 

//Некоторые библиотечные объекты, методы и функции, кроме DOM
new Date(milliseconds)
new Date(year, month, date, hours, minutes, seconds, ms)
console.time(метка) – включить внутренний хронометр браузера с меткой.
console.timeEnd(метка) – выключить внутренний хронометр браузера с меткой и вывести результат.

performance.now() возвращает количество миллисекунд, прошедшее с начала загрузки страницы. Причём именно с самого начала, до того, как загрузился HTML-файл, если точнее – с момента выгрузки предыдущей страницы из памяти.

//============
ООП:

function CoffeeMachine(power) {

  this.waterAmount = 0;

  // расчёт времени для кипячения
  function getBoilTime() {
    return 1000; // точная формула расчета будет позже
  }

  // что делать по окончании процесса
  function onReady() {
    alert( 'Кофе готов!' );
  }

  this.run = function() {
    // setTimeout - встроенная функция,
    // она запустит onReady через getBoilTime() миллисекунд
    setTimeout(onReady, getBoilTime());
  };
}

var coffeeMachine = new CoffeeMachine(100);
coffeeMachine.waterAmount = 200;

coffeeMachine.run();

Приватные методы, такие как onReady, getBoilTime могут быть объявлены как вложенные функции.

В результате естественным образом получается, что доступ к ним (через замыкание) имеют только другие функции, объявленные в том же конструкторе.

Говорят, что класс CoffeeMachine написан в «функциональном» стиле. Далее мы также увидим «прототипный» стиль.


// про прототипы, this и замыкания еще надо будет во вторник. С Аджаксом.




